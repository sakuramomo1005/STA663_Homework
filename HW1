For this first set of exercises, we want to practice using only Python standard libaries. In particular, do not include `numpy`. Use `math` and `random` instead.

# Python data types, collections and flow control

**1**. Make a list of the first 10 odd square numbers. (10 points)

[i**2 for i in range(0,20) if i%2!=0]

**2**. Some code is given below to generate two long lists of random interges. Find the integers present in both lists. (10 points)

import random

random.seed(123)

lower = 0
upper = 100000
n = 1000

x = [random.randint(lower, upper) for i in range(n)]
y = [random.randint(lower, upper) for i in range(n)]

set(x).intersection(y)

print('the integers present in both lists: {}'.format(list(set(x).intersection(y))))

**3**. Make a list of the first 100 [triangular numbers](https://en.wikipedia.org/wiki/Triangular_number) starting from 0. (20 points)

xs=[0]
for i in range(100):
    temp=xs[i]+i
    xs.append(temp)

xs=xs[1:]
len(xs)
print(xs)

**4**. A DNA seqeunce is provided below. It should be treated as a single seqeunce - it is borken into multiple lines for display purposes.

- Find the ratio of the base 'G' to the base 'C'
- What is the reverse complement of the DNA sequence? (The complementary bases are A=T, C=G)
- Make a dictionary of counts for each letter in the sequence. Do not count the newline character.

(20 points)

dna = """
TTTAAATTCCCTGGCACCCGCTGGAGTTCTCGATTTCGAC
CAACCACGACGGTGTGATTCTGAATGTAGTTAGTATCTAC
CCAGAGCTCAGGTCATATCGCGCCAAGCATAAAGGTGGCT
GTTGAAAGTCGATGTCCGTATAAGTTCCGTTTCCTAATGA
AACTGCTACGTAAGTCTAAAGTTATGAGCGCGGGCCGGGT
TAAGGAAGCCCTACGGTTACTATATTACGCCAATATTTCT
CATTCCCTTGCTTTGTTGATTAGGACAGAGGTCACCACAC
CCGGAAGCCCGGTTCACGAGCTCCATCCAACGAGCCTTGC
GAGGTATCGAGCAAACCAATATACTGCTAGGATCCGGTCT
GGCGTTTTACCCCCATGAGATATAGTCCAGGTACTAAAAC
CCTTCACCAGGGCAGAAGCGGGGTATACGCTGCCTACTCG
TCATACAATTTCGGCTGGAGTTCGGTACGATAGACCGAGT
CTGTCGGATACCCGGAAGAGTCACTCTGAAGTTGTACGAG
GTGACTAGCTCAAAAGGAAGGGCGAAGAATGGTATGGTAC
TCTAGAGCAGGCCATCTTTTACATAGGGCCCTTTGTTACC
TTATGTAATGAACGTGGGAGCCCCGGACGTAAATTCTTTA
GTCTCCCTAGACGCGTGGTCCCCACTAAATATACATGGTG
AGCATCGCAGATACATGGCTTATCGAGGCCCGGGTCGTCA
GAAAACGCGGTAAGTCATACGCATGTGCGGCGAATTAGCT
TAGGGTGCGCATCTTCAAGCGGAAGTTCCCCCCGAGTGTC
GACGCGTTCGTGCCATTAAAGCGTCTTCGAGTACGAATTA
GACCAAGTCTGACGAAATTGCCTGAAGTTATAGGGGAAGT
AGTCGAAGGGGACGGAGAACTTGTGAATCATAGCGCATGA
GGAGATTAAGTCGGTTCATCAGCGTAACCACTTTAACCAC
TAGTACGACCCCTGGATGAGTATTGTTCGTGTGTTTCCTC
"""

dna

ratio=dna.count('G')/dna.count('C')
print("ratio of the base 'G' to the base 'C' is {}".format(ratio))

#### method 1: write a function

def complementary(x):
    y=[]
    for i in range(len(x)):
        if x[i]=='T':
            y.append('A')
        elif x[i]=='A':
            y.append('T')
        elif x[i]=='G':
            y.append('C')
        else: 
            y.append('G')
    z="".join(str(x) for x in y)
    return(z)

dna2=dna.replace('\n','')

complementary_dna=complementary(dna2)

complementary_dna



#### method 2: replace function

dna_step1=dna.replace('A','a')
dna_step2=dna_step1.replace('T','A')
dna_step3=dna_step2.replace('a','T')
dna_step4=dna_step3.replace('C','c')
dna_step5=dna_step4.replace('G','C')
dna_step6=dna_step5.replace('c','G')

dna_step6.replace('\n','')==complementary_dna

dna_step6.replace('\n','')

dict(A=dna.count('A'),T=dna.count('T'),C=dna.count('C'),G=dna.count('G'))

**5**. Buffon's needle is a mathematical thought experiment.

Suppose there exist an infinite number of equally spaced parallel lines, and we were to randomly toss a needle whose length is less than or equal to the distance between adjacent lines. What is the probability that the needle will cross a line? The formula is 
$P = \frac{2L}{\pi D}$, where $D$ is the distance between two adjacent lines, and $L$ is the length of the needle.

[Source: Wikipedia](https://en.wikipedia.org/wiki/Buffon%27s_noodle)

Use a Monte Carlo simulaiton and elemntary trignometry to esitmate $\pi$ using Buffon's needle by dropping 1 million  needles. (40 points)

import random 
from numpy import pi, sin

def buffon(L, D, N):
    count= 0; 
    for loop in range(N) :
        theta = pi*random.uniform(0,180)/180
        if L * sin(theta)/2 > random.uniform(0,D)/2: 
            count += 1
    return count/N

#% Prob_hit = 2*L/(D*pi) hence:  Pi_est = 2*L / (P_hit*D); 
L = 2
D = 4
N = int(1e7) 
Pi_est = (2*L) / (buffon(L,D,N)*D)

Pi_est
